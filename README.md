<<<<<<< HEAD
# QUEST

## One-time setup:

You'll need the submodules and dependencies, so clone like so:
```
git clone --recurse-submodules REPO_ADDRESS
```

Or, after cloning, run:
```
git submodule update --init --recursive 
```

To get the F’ dependencies on Ubuntu (all dependencies are available through Homebrew on Mac):
```
sudo apt-get install pkg-config g++ python-pip python-lxml python-tk python-dev
```

On all platforms (modify the pip command if you don’t want a global install)
```
sudo -H pip install -r Gse/bin/required.txt
```

## Using with ROS (needed for `SIMREF` and `SDREF`)

Dependencies:
```
ros-VERSION-trac-ik
ros-VERSION-orocos-kdl
```

For Ubuntu 16.04 with Kinetic, or Ubuntu 18.04 with Melodic, there are pre-written `mod.mk` files here:
https://github.com/genemerewether/quest-fw/blob/quest-master/ROS/fprime_modmk_linux_kinetic
https://github.com/genemerewether/quest-fw/blob/quest-master/ROS/fprime_modmk_linux_melodic

Copy the appropriate file to `ROS/fprime_ws/src/fprime/mod.mk`. If you have some other system not listed above, then you need to enable generation of the `mod.mk` file, so remove the `CATKIN_IGNORE` file from `ROS/fprime_ws/src/fprime` and `ROS/fprime_ws/src/genfprime`.

Then, go to the ROS/fprime_ws folder, and build the workspace with your ROS environment sourced (tested with catkin):
```
catkin init
ROS_LANG_DISABLE=genfprime catkin build
```
(omit the ROS_LANG_DISABLE if you want to generate F' ports / serializables from a new ROS package with messages and/or services)

If you autogenerated the `mod.mk` file, then double-check that `genfprime` didn't overwrite any files in the `ROS/Gen` folder using `git status`.

## Using without ROS
From the top directory of the repo, run:
```
touch ROS/fprime_ws/src/fprime/mod.mk
```

## Installing command dictionaries
For a particular deployment (e.g. `SDREF`, `HEXREF`), go to that folder and run `make dict_install`

Then, run `touch Gse/generated/DEPLOYMENT/serializable/ROS/__init__.py`
See https://github.com/genemerewether/quest-fw/issues/3

## `SDREF`: High-level processor deployment

- Acts as a shim to transport data to and from low-level processor
- Interfaces with ROS and F' ground station
- On Snapdragon Flight, loads `HEXREF` onto DSP and interfaces with that code
- On any Linux environment, interfaces to low-level processor over two UARTS (one data and one debug)

To set up a new installation, download `Flight_3.1.3_qrlSDK.tgz` from Intrinsyc and `qualcomm_hexagon_sdk_lnx_3_0_eval.bin` from Qualcomm, and place in `cross_toolchain/downloads`.

Run `./bootstrap.bash` from the top level of the repository. This will set up the Hexagon toolchain using `install.sh` from `cross_toolchain`, install all required dependencies, create a Linaro Indigo ARM sysroot and install ROS in it using `proot` for later cross-compilation include and link steps.

## `R5REF`: TI TMS570 deployment

Tested on Linux and Mac with TI Code Composer Studio version `8.1.0`, with ARM compiler version `18.1.2`

## `SIMREF`: Simulation deployment (works with RotorS from ETH)

To build the simulation example, go to the SIMREF folder, and run the following:
```
make gen_make
make
```

Then, you can run the executable like so (after starting ROS master):
```
ROS_NAMESPACE=firefly ./linux-linux-x86-debug-gnu-bin/SIMREF
```

When you start the RotorS (https://github.com/ethz-asl/rotors_simulator) firefly example, SIMREF will use the /clock message to carry out control cycles. This parallels what happens on hardware targets, where the IMU data-ready interrupt triggers the estimation and control loops.

Works out of the box with https://github.com/genemerewether/ethzasl_sensor_fusion for testing high-level filter updates, but can be easily adapted to simulated sensors in Gazebo. Just run additional ROS nodes as necessary, and remap the pose or position sensor topics of the sensor fusion packages. Or, publish the `mav_msgs/ImuStateUpdate` message (see the `mav_msgs` submodule of this repo) from an appropriate filter.

## Snapdragon build:

To build for the 820, clean the entire repo or start with a fresh copy and make sure the correct environment variable is present:

```
echo "export TARGET_8096=1" >> ~/.bashrc
. ~/.bashrc
```

## Supported Hardware:

* ATI Netbox force-torque sensor
* MPU9250
* Garmin LidarLite v3
* SimonK ESC firmware over I2C, two different protocols: https://github.com/genemerewether/tgy

# fprime
=======
# F Prime: A Flight-Proven, Multi-Platform, Open-Source Flight Software Framework
>>>>>>> upstream-pub-fprime/master

F Prime (FÊ¹) is a component-driven framework that enables rapid development and deployment of spaceflight and other embedded software applications. Originally developed at the Jet Propulsion Laboratory, F Prime has been successfully deployed on several space applications. It is tailored, but not limited, to small-scale spaceflight systems such as CubeSats, SmallSats, and instruments. 

F Prime comprises several elements: 

* An architecture that decomposes flight software into discrete components with well-defined interfaces
* A C++ framework that provides core capabilities such as message queues and threads
* Modeling tools for specifying components and connections and automatically generating code
* A growing collection of ready-to-use components
* Testing tools for testing flight software at the unit and integration levels.

F Prime has the following key features:

### Reusability

F Primeâ€™s component-based architecture enables a high degree of modularity and software reuse. 

<<<<<<< HEAD
Updated contributor list. No code changes. 
=======
### Rapid Deployment

F Prime provides a complete development ecosystem, including modeling tools, testing tools, and a ground data system. Developers use the modeling tools to write high-level specifications, automatically generate implementations in C++, and fill in the implementations with domain-specific code. The framework and the code generators provide all the boilerplate code required in an F Prime deployment, including code for thread management, code for communication between components, and code for handling commands, telemetry, and parameters. The testing tools and the ground data system simplify software testing, both on workstations and on flight hardware in the lab.

### Portability

F Prime runs on a wide range of processors, from microcontrollers to multicore computers, and on several operating systems. Porting F Prime to new operating systems is straightforward.

### High Performance

F Prime utilizes a point-to-point architecture. The architecture minimizes the use of computational resources and is well suited for smaller processors.
	
### Adaptability

F Prime is tailored to the level of complexity required for small missions. This makes it accessible and easy to use, while still supporting a wide variety of missions.

### Analyzability

The typed port connections provide strong compile-time guarantees of correctness.

## F Prime Resources

The Reference application is shipped as part of F'. Documentation for this reference application can be found [here.](Ref/docs/sdd.md)

The full F' User's guide can be found [here.](docs/UsersGuide/FprimeUserGuide.pdf) In addition, the F' architectural overview can be found [here.](docs/Architecture/FPrimeArchitectureShort.pdf)

## Continuous Integration

The continous integration system performs builds and unit-test check on any pull-requests created on the F´ core. Thus ensuring that F´ core is stable and well maintained.

## F Prime Release Notes

#### Release 1.0: 

 * This is the initial release of the software to open source. See the license file for terms of use.

#### Release 1.01

 * Updated contributor list. No code changes. 

#### Release 1.1

 * Created a Raspberry Pi demo. Read about it [here.](RPI/README.md)
 * Added a tutorial [here.](docs/Tutorials/README.md)
 * Updated Svc/BufferManager with bug fix
 * Fixed a bunch of shell permissions
 
#### Release 1.2

* Better MagicDraw Plugin
* Prototype CMake build system. See: [CMake Readme](cmake/README.md)
* Mars Helicopter Project fixes migrated in
* Python 3 support added
* Gse refactored and renamed to Gds
* Wx frontend to Gds
* UdpSender and UdpReceiver components added
* Purged inaccurate ITAR and Copyright notices
* Misc. bug fixes
>>>>>>> upstream-pub-fprime/master
